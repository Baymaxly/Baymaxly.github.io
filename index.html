<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Baymaxly（卢意个人博客）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Baymaxly（卢意个人博客）">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Baymaxly（卢意个人博客）">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Baymaxly">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/image/avator.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.dabb16.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#4d4d4d,#ccc);
    }
  </style>
  

  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      

<div class="overlay" style="background: #4d4d4d"></div>


<!--

<div class="overlay"></div>

	<script >
	var bglist = [];
	bglist[0] = "https://s2.ax1x.com/2020/01/19/1CuNVJ.jpg";
	bglist[1] = "https://s2.ax1x.com/2020/01/19/1CuNVJ.jpg";
	bglist[2] = "https://s2.ax1x.com/2020/01/19/1CuNVJ.jpg";
	setInterval('Getbg();', 3000);   //切换时间间隔，单位毫秒
	function Getbg(){
				var bgindex = Math.round(Math.random()*2);
				//输出随机背景
				var bkg = document.getElementsByClassName("left-col")[0];  
				//这句话意思是找名字是left-col的class元素，找id可以用getElementById()
				bkg.style.backgroundImage="url("+ bglist[bgindex] +")";
}
</script>

-->
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="" class="profilepic">
			        <img src="/image/avator.png" class="js-avatar show">
		</a>
                          
		<hgroup>
		  <h1 class="header-author"><a href="">Baymaxly</a></h1>
		</hgroup>
		


		<nav>
		    你只有足够努力
		</nav>
		<nav>
			才能看起来毫不费力
		</nav>

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/categories">分类</a></li>
	        
				<li><a href="/archives">归档</a></li>
	        
			</ul>
		</nav>

		<nav>
			总文章数 24
		</nav>

		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友情链接</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/Baymaxly" title="github"><i class="icon-github"></i></a>
		        
					<a class="csdn" target="_blank" href="https://me.csdn.net/weixin_43955214" title="csdn"><i class="icon-csdn"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="jianshu" target="_blank" href="#" title="jianshu"><i class="icon-jianshu"></i></a>
		        
			</div>
		</nav>
	
	</header>		
</div>


    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/image/avator.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">Baymaxly</h1>
			</hgroup>
			
			
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Baymaxly" title="github"><i class="icon-github"></i></a>
			        
						<a class="csdn" target="_blank" href="https://me.csdn.net/weixin_43955214" title="csdn"><i class="icon-csdn"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="jianshu" target="_blank" href="#" title="jianshu"><i class="icon-jianshu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 33.333333333333336%"><a href="/">主页</a></li>
		        
					<li style="width: 33.333333333333336%"><a href="/categories">分类</a></li>
		        
					<li style="width: 33.333333333333336%"><a href="/archives">归档</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-常用的DEBUG宏汇总" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/14/%E5%B8%B8%E7%94%A8%E7%9A%84DEBUG%E5%AE%8F%E6%B1%87%E6%80%BB/">【C语言】常用的DEBUG宏汇总</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/14/%E5%B8%B8%E7%94%A8%E7%9A%84DEBUG%E5%AE%8F%E6%B1%87%E6%80%BB/" class="archive-article-date">
  	<time datetime="2020-02-14T12:15:49.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-14</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <h2 id="一、printf函数与fprintf函数"><a href="#一、printf函数与fprintf函数" class="headerlink" title="一、printf函数与fprintf函数"></a>一、printf函数与fprintf函数</h2><h3 id="1-1-printf"><a href="#1-1-printf" class="headerlink" title="1.1 printf"></a>1.1 printf</h3><p>printf的函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用于将格式化后的字符串输出到标准输出。标准输出，即标准输出文件，对应终端的屏幕。printf称为可变参数函数，其定义声明和普通函数相同。在其参数列表中，<code>format</code>称为固定参数部分，<code>...</code>称为参数占位符，二者共同构成可变参数。也就是说，它除了有一个参数format固定以外，后面的参数其个数和类型都是可变的。</p>
<h3 id="1-2-fprintf"><a href="#1-2-fprintf" class="headerlink" title="1.2 fprintf"></a>1.2 fprintf</h3><p>fprintf的函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用于把格式化字符串输出到指定文件中，所以参数列表比printf多了个文件指针FILE * ,那是目标文件的文件描述符(文件流指针)，stdout即标准输出文件，对应屏幕的终端。也就是说fprintf的第一个参数为stdout时，等效于printf</p>
<h2 id="二、几个预定义宏"><a href="#二、几个预定义宏" class="headerlink" title="二、几个预定义宏"></a>二、几个预定义宏</h2><table>
<thead>
<tr>
<th align="left">预定义宏</th>
<th align="left">在预编译时被替换成的内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>__FILE__</code></td>
<td align="left">当前的源文件名</td>
</tr>
<tr>
<td align="left"><code>__LINE__</code></td>
<td align="left">当前的行号</td>
</tr>
<tr>
<td align="left"><code>__FUNCTION__</code></td>
<td align="left">当前的函数名称</td>
</tr>
<tr>
<td align="left"><code>__DATE__</code></td>
<td align="left">当前的编译日期</td>
</tr>
<tr>
<td align="left"><code>__TIME__</code></td>
<td align="left">当前的编译时间</td>
</tr>
</tbody></table>
<h2 id="三、两个常用debug宏"><a href="#三、两个常用debug宏" class="headerlink" title="三、两个常用debug宏"></a>三、两个常用debug宏</h2><h3 id="3-1-普通版"><a href="#3-1-普通版" class="headerlink" title="3.1 普通版"></a>3.1 普通版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_TIMER_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USER_TIMER_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_debug(format, ...) printf(\</span></span><br><span class="line"><span class="string">"[\ttimer]debug:"</span> format <span class="string">"\r\n"</span>, ##__VA_ARGS__)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_debug(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>printf中的format和宏体中的format对应，会进行直接的替换</li>
<li><strong>VA_ARGS</strong>是一个可变参数宏，在预编译阶段会替代宏体中…的内容</li>
<li><strong>VA_ARGS</strong>宏前面加上##的作用在于，当可变参数的个数为0时，把前面多余的”,”去，否则会编译出错，如下图所示：<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/debug/clipboard_20200214103712.png" alt="clipboard_20200214103712.png"><br>加上##则不会出错：<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/debug/clipboard_20200214103839.png" alt="clipboard_20200214103839.png"></li>
</ol>
<h3 id="3-2-进阶版"><a href="#3-2-进阶版" class="headerlink" title="3.2 进阶版"></a>3.2 进阶版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG(format, ...) fprintf(stdout, \</span></span><br><span class="line"><span class="string">"[\tDBG](File:%s, Func:%s(), Line:%d): "</span> \</span><br><span class="line">, __FILE__, __FUNCTION__, __LINE__);     \</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, format<span class="string">"\r\n"</span>, ##__VA_ARGS__)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG(format, ...)  do &#123;&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>此版本可以自行打印调试的文件信息，加上do {} while (0)是为了消除;，不消除也不会引起语法错误</p>
<p>在gcc中还支持在宏体中用args…代替…，表示后续的args可能会有多个，在函数中则用##args代替##<strong>VA_ARGS</strong>，如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LG(format, args...) fprintf(stdout,\</span></span><br><span class="line"><span class="string">"[\tLOG](File:%s, Func:%s(), Line:%d): "</span>   \</span><br><span class="line">, __FILE__, __FUNCTION__, __LINE__);       \</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, format<span class="string">"\r\n"</span>, ##args)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LG(format, args...)  do &#123;&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">C</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">宏定义</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">预处理</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/14/%E5%B8%B8%E7%94%A8%E7%9A%84DEBUG%E5%AE%8F%E6%B1%87%E6%80%BB/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
    <article id="post-【Cpp】namespace详解" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/14/%E3%80%90Cpp%E3%80%91namespace%E8%AF%A6%E8%A7%A3/">【Cpp】命名空间namespace详解</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/14/%E3%80%90Cpp%E3%80%91namespace%E8%AF%A6%E8%A7%A3/" class="archive-article-date">
  	<time datetime="2020-02-14T04:44:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-14</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <h2 id="一、命名空间的引入"><a href="#一、命名空间的引入" class="headerlink" title="一、命名空间的引入"></a>一、命名空间的引入</h2><p><code>C++</code>中，名称<code>(name)</code>可以是符号常量、变量、宏、函数、结构体、枚举、类和对象等等。而在大型工程中，难免会有重名的现象，命名空间<code>namespace</code>，就是<code>C++</code>引入的一种解决名称冲突的机制</p>
<h3 id="1-1-如何解决命名冲突"><a href="#1-1-如何解决命名冲突" class="headerlink" title="1.1 如何解决命名冲突"></a>1.1 如何解决命名冲突</h3><h4 id="C语言中"><a href="#C语言中" class="headerlink" title="C语言中"></a>C语言中</h4><p>C语言中是通过人为操作符号名称、限制符号的作用域和链接属性来完解决名称冲突的。比如：</p>
<blockquote>
<ol>
<li>同一个C文件中的全局变量/函数加一个统一的前缀</li>
<li>通过作用域的掩蔽规则来进行覆盖(在大文件中如果出错很难发现)</li>
<li>C文件中的全局变量和函数都是<code>extern</code>链接属性，可以用<code>static</code>将无需跨文件访问的全局变量和函数限制在内链接属性中</li>
</ol>
</blockquote>
<h4 id="Cpp中"><a href="#Cpp中" class="headerlink" title="Cpp中"></a>Cpp中</h4><p>为实现命名空间机制，<code>C++</code>中引入了<code>namespace</code>关键字，定义格式为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NAME</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        符号定义</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个特定名称为<code>NAME</code>的命名空间的一对大括号内部定义的符号均被限制在该命名空间内，在命名空间内部各符号可以直接相互引用，而跨命名空间相互引用时必须同时指定被引用符号的命名空间名称。从某种意义上来说，命名空间就类似于一种前缀，本质上而言，就相当于控制了符号的作用域和链接属性。</p>
<h2 id="二、namespace的使用"><a href="#二、namespace的使用" class="headerlink" title="二、namespace的使用"></a>二、<code>namespace</code>的使用</h2><p>需要注意的是，命名空间不能定义在任何函数的内部，包括主函数，但是可以嵌套定义。</p>
<h3 id="2-1-同一文件内常规使用namespace"><a href="#2-1-同一文件内常规使用namespace" class="headerlink" title="2.1 同一文件内常规使用namespace"></a>2.1 同一文件内常规使用<code>namespace</code></h3><p><code>namespace</code>有三种使用方法:</p>
<ol>
<li>使用时对符号附带命名空间的名称</li>
<li>使用前对该符号进行声明，后面直接使用该符号</li>
<li>使用前声明整个命名空间，后面对直接使用该命名空间中的任何符号</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NM1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//声明std命名空间，后面可以使用该命名空间中的任何符号，如cout、endl...</span></span><br><span class="line"><span class="keyword">using</span> NM1::a;       <span class="comment">//声明命名空间NM1中的a，后面可以直接对a进行使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"the value of a is: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"the value of b is: "</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; NM1::b;<span class="comment">//使用变量时直接附带命名空间</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-命名空间内定义函数"><a href="#2-2-命名空间内定义函数" class="headerlink" title="2.2 命名空间内定义函数"></a>2.2 命名空间内定义函数</h3><p>我们可以在命名空间内直接定义函数，但是不能只声明不定义，否者链接时会出错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NM1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Func1 in NM1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NM1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func1();</span><br><span class="line">    func2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是合法的使用<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Cpp/Namespace/clipboard_20200214030329.png" alt="clipboard_20200214030329.png"></p>
<p>如果我们只声明，而在默认命名空间（后文会阐述）中去定义，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NM1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NM1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Func1 in NM1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则会出现链接错误，因为<code>func1</code>在定义和声明时不再同一个作用域<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Cpp/Namespace/clipboard_20200214030932.png" alt="clipboard_20200214030932.png"></p>
<h3 id="2-3-嵌套使用命名空间"><a href="#2-3-嵌套使用命名空间" class="headerlink" title="2.3 嵌套使用命名空间"></a>2.3 嵌套使用命名空间</h3><p>这个东西也很简单，如下测试代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NEST1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Func1 in NEST1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> NEST2</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Func2 in NEST1::NEST2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NEST1::func1();</span><br><span class="line">    NEST1::NEST2::func2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Cpp/Namespace/clipboard_20200214032209.png" alt="clipboard_20200214032209.png"></p>
<h3 id="2-4-跨文件使用namespace"><a href="#2-4-跨文件使用namespace" class="headerlink" title="2.4 跨文件使用namespace"></a>2.4 跨文件使用namespace</h3><p>建立相应的测试文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch external_test.cpp external_test.h main.cpp CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>对应的内容如下：</p>
<p><code>external_test.h</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPP_EXTERNAL_TEST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPP_EXTERNAL_TEST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> EX1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>external_test.cpp</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"external_test.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> EX1</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Func in EX1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main.cpp</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"external_test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> EX1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下，<code>EX1</code>成功跨文件调用<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Cpp/Namespace/clipboard_20200214042524.png" alt="clipboard_20200214042524.png"><br>在正规场合都是通过头文件的包含来进行<code>namespace</code>的跨文件调用，有时也可以通过对命名空间内的符号进行<code>extern</code>全局声明</p>
<p>建立相应的测试文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch external_test.cpp main.cpp CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>相应内容如下：</p>
<p><code>extern_test.cpp</code>中:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> EX1</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Func in EX1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main.cpp</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> EX1</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> EX1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Cpp/Namespace/clipboard_20200214044616.png" alt="clipboard_20200214044616.png"></p>
<h2 id="三、一些特殊的命名空间"><a href="#三、一些特殊的命名空间" class="headerlink" title="三、一些特殊的命名空间"></a>三、一些特殊的命名空间</h2><h3 id="3-1-std命名空间"><a href="#3-1-std命名空间" class="headerlink" title="3.1 std命名空间"></a>3.1 std命名空间</h3><p>标准<code>C++</code>库的所有的标识符(函数、类、模板等)是在一个名为<code>std</code>的命名空间中定义的，<code>std</code>是<code>standard</code>(标准)的缩写，表示这是存放标准库的有关内容的命名空间。</p>
<h3 id="3-2-默认命名空间"><a href="#3-2-默认命名空间" class="headerlink" title="3.2 默认命名空间"></a>3.2 默认命名空间</h3><p>默认命名空间又叫全局命名空间，就是除了其他的命名空间之外的部分，比如说我们的主函数就是在默认命名空间中的，在其他命名空间引用默认命名空间中的符号的方法有两种：</p>
<blockquote>
<ol>
<li>直接使用</li>
<li>在符号前加<code>::</code></li>
</ol>
</blockquote>
<h3 id="3-3-匿名命名空间"><a href="#3-3-匿名命名空间" class="headerlink" title="3.3 匿名命名空间"></a>3.3 匿名命名空间</h3><p>匿名命名空间就是没有名字的命名空间，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        符号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名命名空间中的符号纯本空间内部使用，不能被外部引用，效果类似于全局变量和函数加<code>static</code>，但是比C中的<code>static</code>使用范围广</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">Cpp</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">namespace</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/14/%E3%80%90Cpp%E3%80%91namespace%E8%AF%A6%E8%A7%A3/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
    <article id="post-存储类、作用域、生命周期与链接属性" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/12/%E5%AD%98%E5%82%A8%E7%B1%BB%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7/">【C语言】存储类、作用域、生命周期与链接属性</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/12/%E5%AD%98%E5%82%A8%E7%B1%BB%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7/" class="archive-article-date">
  	<time datetime="2020-02-12T11:31:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-12</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <h2 id="一、概念解析与内存映像"><a href="#一、概念解析与内存映像" class="headerlink" title="一、概念解析与内存映像"></a>一、概念解析与内存映像</h2><h3 id="1-1-概念解析"><a href="#1-1-概念解析" class="headerlink" title="1.1 概念解析"></a>1.1 概念解析</h3><ol>
<li>存储类：内存有多种管理方法：<code>stack、heap、.data、bss段、.text</code>等，一个变量的存储类属性就是描述这个变量存储在何种内存段中。</li>
<li>作用域：用来描述一个符号(变量、函数等)起作用的范围。</li>
<li>生命周期：用来描述变量的诞生(给变量分配内存)与消亡(回收分配的内存空间，此时变量无权访问此内存空间)</li>
<li>链接属性：一个程序从源代码到最终的可执行程序需要经过编译链接，编译生成的.o目标文件中有很多符号(变量、函数等)及内存分段(<code>.data、.bss、.text</code>等)，其链接生成可执行程序的时候，就是把符号和对应的段给链接起来，此时就涉及到C语言符号中的三种链接属性：外链接属性、内链接属性、无链接属性</li>
</ol>
<h3 id="1-2-linux下C程序的内存映像"><a href="#1-2-linux下C程序的内存映像" class="headerlink" title="1.2 linux下C程序的内存映像"></a>1.2 linux下C程序的内存映像</h3><table>
<thead>
<tr>
<th align="left">内存段</th>
<th align="left">存储的内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">代码段(文本段.text)</td>
<td align="left">程序中的代码(函数)、字符串常量、单片机中const修饰的常量</td>
</tr>
<tr>
<td align="left">只读数据段</td>
<td align="left">gcc中const修饰的常量</td>
</tr>
<tr>
<td align="left">数据段(.data)</td>
<td align="left">显式初始化为非零的全局变量、显式初始化为非零的static局部变量</td>
</tr>
<tr>
<td align="left">bss段</td>
<td align="left">显式初始化为0和未显式初始化的全局变量、显式初始化为0或未显式初始化的static局部变量</td>
</tr>
<tr>
<td align="left">堆(heap)</td>
<td align="left">程序员自行malloc和free</td>
</tr>
<tr>
<td align="left">栈(stack)</td>
<td align="left">局部变量、函数传参</td>
</tr>
<tr>
<td align="left">文件映射区</td>
<td align="left">进程打开文件时将整个文件内容从硬盘读到进程的文件映射区，在内存中操作文件，操作完成后保存时将内存中的文件写入硬盘</td>
</tr>
<tr>
<td align="left">内核映射区</td>
<td align="left">操作系统内核程序映射的区域，对于4G内存的机器0xC0000000以上都是是OS内核的活动空间</td>
</tr>
</tbody></table>
<h3 id="1-3-OS下和裸机下C程序加载执行的差异"><a href="#1-3-OS下和裸机下C程序加载执行的差异" class="headerlink" title="1.3 OS下和裸机下C程序加载执行的差异"></a>1.3 OS下和裸机下C程序加载执行的差异</h3><p>C语言的程序运行时对环境有一定的要求，单个人写的C程序是没法在内存中直接运行的，需要外部协助代码。这段外部协助代码用来构建C运行时的环境，又叫加载运行代码。</p>
<h4 id="有OS"><a href="#有OS" class="headerlink" title="有OS"></a>有OS</h4><p>加载运行代码由开发着写好存放在<code>OS</code>下，会自动添加到我们写的程序中，这段代码的主要作用是：给全局变量赋值、清<code>bss</code>段。即在<code>OS</code>运行程序时会自动完成重定位和清<code>bss</code>，所以：</p>
<blockquote>
<ol>
<li>数据段的全局变量或静态局部变量都是有非0的初值的，这些初值在main函数运行之前(重定位期间)就已经被初始化了</li>
<li>C语言中未初始化的全局变量和<code>static</code>局部变量默认为0</li>
</ol>
</blockquote>
<h4 id="裸机"><a href="#裸机" class="headerlink" title="裸机"></a>裸机</h4><p>在<code>ARM</code>裸机下定义的全局变量初始化为0但是经常会不为0，这是因为程序员没在裸机的<code>start.S</code>中清<code>bss</code>段代码。这就说明在裸机中要程序员自己做加载运行代码(<code>start.S</code>中的重定位和清<code>bss</code>段)</p>
<h2 id="二、存储类相关的关键字"><a href="#二、存储类相关的关键字" class="headerlink" title="二、存储类相关的关键字"></a>二、存储类相关的关键字</h2><h3 id="2-1-auto"><a href="#2-1-auto" class="headerlink" title="2.1 auto"></a>2.1 auto</h3><p><code>auto</code>关键字在C语言中用来修饰静态局部变量，表示该局部变量为静态局部变量，该变量配在栈上。平时我们在函数内定义的普通局部变量都是<code>auto</code>的，只是省略了<code>auto</code>关键字（所以<code>auto</code>的存在感极低……）不过，在C11中auto有了很大的改动，详见以下文章：</p>
<p><a href="https://www.cnblogs.com/LyndonYoung/articles/5438436.html" target="_blank" rel="noopener">C11中的类型推导auto的使用</a><br><a href="https://www.cnblogs.com/sollyu/p/4184515.html" target="_blank" rel="noopener">【C++11】新特性——auto的使用</a></p>
<h3 id="2-2-static"><a href="#2-2-static" class="headerlink" title="2.2 static"></a>2.2 static</h3><p><code>static</code>关键字在C语言中有2种用法，这两种用法无任何关联</p>
<blockquote>
<ol>
<li>用来修饰局部变量，形成静态局部变量，分配在.data或bbs段</li>
<li>用来修饰全局变量，形成静态全局变量。链接属性为无链接属性</li>
</ol>
</blockquote>
<p><code>static</code>局部变量与全局变量的比较如下：</p>
<table>
<thead>
<tr>
<th align="left">比较类别</th>
<th align="center">static局部变量</th>
<th align="center">全局变量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储类</td>
<td align="center">一样</td>
<td align="center">一样</td>
</tr>
<tr>
<td align="left">生命周期</td>
<td align="center">一样</td>
<td align="center">一样</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="center">代码块作用域，和普通局部变量一样</td>
<td align="center">文件作用域，和函数一样</td>
</tr>
<tr>
<td align="left">链接属性</td>
<td align="center">无链接</td>
<td align="center">外链接</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/guotianqing/article/details/79828100" target="_blank" rel="noopener">关于<code>stctic</code>这里有一篇高质量博文:c语言中static关键字用法详解</a></p>
<h3 id="2-3-register"><a href="#2-3-register" class="headerlink" title="2.3 register"></a>2.3 register</h3><p><code>register</code>修饰的变量编译器会尽量将其分配在寄存器中，大幅提升读写效率。所以<code>register</code>用来修饰那种反复高频率的使用变量，是一种极致的提升程序运行效率的手段。因为<strong>寄存器数量有限</strong>，所以一般不是非必要，不会定义<code>register</code>变量。同时，编译器只能承诺尽量将<code>register</code>修饰的变量放在寄存器中，不保证一定放在寄存器中。以下这篇博文比较了int变量和register int变量的速度：</p>
<p><a href="https://blog.csdn.net/mouse_ts/article/details/45097603" target="_blank" rel="noopener">C语言寄存器变量register</a></p>
<h3 id="2-4-extern"><a href="#2-4-extern" class="headerlink" title="2.4 extern"></a>2.4 extern</h3><p><code>extern</code>主要用来声明全局变量，声明的目的主要是跨文件使用变量。因为C语言中编译是以单文件为单位的，当在一个.c文件中使用了同工程下另一.c文件中的变量时，就要用<code>extern</code>声明</p>
<p><a href="https://blog.csdn.net/qq_38880380/article/details/81474580" target="_blank" rel="noopener">这有一篇精炼的总结：extern使用方法总结！</a></p>
<h3 id="2-5-volatile"><a href="#2-5-volatile" class="headerlink" title="2.5 volatile"></a>2.5 volatile</h3><p><code>volatile</code>用来修饰一个变量，表示这个变量可以被编译器之外的东西改变。也就是说这个改变不是当前代码造成的，编译器在编译当前代码时无法预知。通常是以下三种情况的变量：</p>
<blockquote>
<ol>
<li>中断isr中引用的变量</li>
<li>多线程中共用的变量</li>
<li>硬件会更改的变量（通常是寄存器的值）</li>
</ol>
</blockquote>
<p>遇到以上三种变量都应用使用<code>volatile</code>修饰，告诉编译器这个变量值的改变它无法预知。编译器在遇到<code>volatile</code>修饰的变量时就不会对改变量的访问进行优化，就不会出现错误。</p>
<blockquote>
<ul>
<li>编译器的优化在一般情况下非常好，可以帮助提升程序效率。但是在变量会被编译器想象之外的力量改变的情况下，此时如果编译器没有意识到而去优化则就会造成优化错误，带来执行时错误，而且这种错误很难被发现</li>
</ul>
</blockquote>
<p><a href="https://blog.csdn.net/tigerjibo/article/details/7427366" target="_blank" rel="noopener">推荐文章：C语言中volatile关键字的作用</a></p>
<h3 id="2-6-restrict"><a href="#2-6-restrict" class="headerlink" title="2.6 restrict"></a>2.6 restrict</h3><p><code>restrict</code>关键字是<code>c99</code>中才支持的和编译器行为特征有关的一个存储类关键字，只用来修饰指针，不能修饰普通变量。该关键字用于告知编译器，所有修改<code>该指针所指向内容的操作</code>全部都是基于该指针的，即不存在其它进行修改操作的途径，这样可以帮助编译器进行更好的代码优化，生成更有效率的汇编代码。</p>
<p><a href="http://blog.chinaunix.net/uid-22197900-id-359209.html" target="_blank" rel="noopener">详见参考文章：restrict关键字用法</a></p>
<h2 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h2><p>作用域就是一个符号(变量、函数等)起作用的范围。</p>
<h3 id="3-1-局部变量的代码块作用域"><a href="#3-1-局部变量的代码块作用域" class="headerlink" title="3.1 局部变量的代码块作用域"></a>3.1 局部变量的代码块作用域</h3><ul>
<li>代码块可以理解为一对大括号{}括起来的部分，不等于函数，因为<code>if/for</code>等语法都有{}，可以说函数是由一个或多个代码块构成的</li>
<li>局部变量的代码块作用域，是说一个局部变量可以被访问和使用的范围仅限于声明这个局部变量的代码块中声明之后的部分，如</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述函数中，<code>count</code>的作用域就是<code>line3~line10</code>，<code>i</code>的作用域仅限于<code>line5</code>，<code>a</code>的作用域为<code>line7~line9</code>；超过作用域去访问变量都是非法的，编译器会报未声明的错误！</p>
<h3 id="3-2-函数名和全局变量的文件作用域"><a href="#3-2-函数名和全局变量的文件作用域" class="headerlink" title="3.2 函数名和全局变量的文件作用域"></a>3.2 函数名和全局变量的文件作用域</h3><ul>
<li>文件作用域的意思就是全局的访问权限，也就是说整个.c文件中都可以访问这些东西。</li>
<li>函数和全局变量的作用域是所在的整个.c文件之内声明之后的部分。</li>
</ul>
<h3 id="3-3-几个注意点"><a href="#3-3-几个注意点" class="headerlink" title="3.3 几个注意点"></a>3.3 几个注意点</h3><blockquote>
<ol>
<li>在<code>c89</code>标准中，所有的局部变量必须先定义在最前面，在变量定义之前不能有一句执行代码。在<code>c99</code>及以后的标准中，允许在当前代码段中使用前的任意位置声明并定义。</li>
<li>不管是局部变量、全局变量还是函数，使用前都要先声明/定义</li>
<li>局部变量的定义和声明是在一起的，全局变量和函数的定义和声明可以分开进行，也可以同时进行，如下代码</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_a; <span class="comment">//声明</span></span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;   <span class="comment">//定义并声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//定义并声明</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        业务代码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;<span class="comment">//定义并声明</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;<span class="comment">//定义并声明</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_a = %d\n"</span>, g_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_b = %d\n"</span>, g_b);</span><br><span class="line">    func1();</span><br><span class="line">    func2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        业务代码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-同名变量的掩蔽规则"><a href="#3-4-同名变量的掩蔽规则" class="headerlink" title="3.4 同名变量的掩蔽规则"></a>3.4 同名变量的掩蔽规则</h3><p>编程时，不可避免会出现同名变量。变量同名后不一定会出错。</p>
<blockquote>
<ul>
<li>如果两个同名变量作用域不同且没有交叠，这种情况下同名没有任何影响。</li>
<li>如果两个同名变量作用域有交叠，C语言规定在作用域交叠范围内，作用域小的变量会掩蔽掉作用域大的</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; ;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"while in for, a = %d\n"</span>, a);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"only in main, a = %d\n"</span>,a);</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"when in func, a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/%E4%BD%9C%E7%94%A8%E5%9F%9F/clipboard_20200214120413.png" alt="clipboard_20200214120413.png"><br>我们可以看到，在不同的代码块中可以定义相同的变量，在变量作用域有交叠的时候，小的掩蔽大的</p>
<h2 id="四、变量的生命周期"><a href="#四、变量的生命周期" class="headerlink" title="四、变量的生命周期"></a>四、变量的生命周期</h2><p>研究变量生命周期，有助于理解变量的行为特征。生命周期和存储类是紧密关联的</p>
<h3 id="4-1-栈变量的生命周期"><a href="#4-1-栈变量的生命周期" class="headerlink" title="4.1 栈变量的生命周期"></a>4.1 栈变量的生命周期</h3><p>局部变量（栈变量）存储在栈上，生命周期是临时的，代码执行过程中按照需要去创建、使用、消亡该局部变量。比如一个函数内定义的局部变量，在这个函数每一次被调用时都会创建一次，然后使用，最后在函数返回的时候消亡。</p>
<h3 id="4-2-堆变量的生命周期"><a href="#4-2-堆变量的生命周期" class="headerlink" title="4.2 堆变量的生命周期"></a>4.2 堆变量的生命周期</h3><p>堆内存空间是客观存在的，是由操作系统维护的（由堆管理器管理），程序只是去申请然后使用然后释放。堆内存从<code>malloc</code>申请时诞生，然后使用，直到<code>free</code>时消亡。</p>
<h3 id="4-3-数据段、bss段变量的生命周期"><a href="#4-3-数据段、bss段变量的生命周期" class="headerlink" title="4.3 数据段、bss段变量的生命周期"></a>4.3 数据段、bss段变量的生命周期</h3><p>全局变量的生命周期是永久的，在程序被执行时诞生，在程序终止时消亡。全局变量所占用的内存是不能被程序自己释放的，所以程序如果申请了过多的全局变量会导致这个程序一直占用大量内存。</p>
<h3 id="4-4-代码段、只读段的生命周期"><a href="#4-4-代码段、只读段的生命周期" class="headerlink" title="4.4 代码段、只读段的生命周期"></a>4.4 代码段、只读段的生命周期</h3><p>代码段和只读段的生命周期是永久的，有时候放在代码段的不只是代码，还有<code>const</code>类型的常量，字符串常量。（<code>const</code>类型的常量、字符串常量有时候放在<code>rodata</code>段，有时候放在代码段，取决于平台）</p>
<h2 id="五、链接属性"><a href="#五、链接属性" class="headerlink" title="五、链接属性"></a>五、链接属性</h2><h3 id="5-1-C语言程序的组织架构"><a href="#5-1-C语言程序的组织架构" class="headerlink" title="5.1 C语言程序的组织架构"></a>5.1 C语言程序的组织架构</h3><ul>
<li>一个庞大、完整的一个C语言程序(linux内核、uboot等)是由多个.c文件和多个.h文件组成的</li>
<li>程序的生成过程可以简单理解为编译+链接。编译是为了将符号变成.o二进制的机器码格式，链接是为了将各个独立分开的二进制的函数链接起来形成一个整体的二进制可执行程序。</li>
<li><strong>编译以文件为单位、链接以工程为单位</strong>，编译器工作时是将所有源文件依次读进来，单个为单位进行编译的。链接的时候实际上是把第一步编译生成个单个的.o文件整体的输入，然后处理链接成一个可执行程序。</li>
</ul>
<h3 id="5-2-三种链接属性：外连接、内链接、无链接"><a href="#5-2-三种链接属性：外连接、内链接、无链接" class="headerlink" title="5.2 三种链接属性：外连接、内链接、无链接"></a>5.2 三种链接属性：外连接、内链接、无链接</h3><ol>
<li>外链接属性，表示符号可以在整个程序范围内（可以跨文件）进行链接，如普通的函数和全局变量属于外连接。</li>
<li>内链接属性，就是说符号只能在当前<code>c</code>文件内部范围内进行链接（就是不能在当前<code>c</code>文件外面的其他<code>c</code>文件中进行访问、链接）。<code>static</code>修饰的函数/全局变量属于内链接。</li>
<li>无链接属性，就是说符号本身不参与链接，跟链接没关系。所有的局部变量（<code>auto、static</code>）和<code>inline</code>函数是无链接的</li>
</ol>
<h3 id="5-3-函数和全局变量的同名冲突"><a href="#5-3-函数和全局变量的同名冲突" class="headerlink" title="5.3 函数和全局变量的同名冲突"></a>5.3 函数和全局变量的同名冲突</h3><p>函数和全局变量是外部链接属性，每一个函数和全局变量将来在整个程序中所有的c文件都能被访问，因此在一个程序中的所有c文件中不能出现同名的函数/同名的全局变量。但是一个很大的工程中函数和全局变量名称不计其数，而且一个大工程是多人协作完成，很难保证不会重名，所以C语言引入了链接属性（在高级语言中的<code>namespace</code>和链接属性有异曲同工之妙）。</p>
<h3 id="5-4-static修饰全局变量和函数"><a href="#5-4-static修饰全局变量和函数" class="headerlink" title="5.4 static修饰全局变量和函数"></a>5.4 <code>static</code>修饰全局变量和函数</h3><p>普通的（非静态）的函数/全局变量，默认的链接属性是外部的，<code>static</code>修饰的（静态）的函数/全局变量，链接属性是内部链接，如果一个同名的函数/全局变量在多个文件中定义，一定要加上<code>static</code>以限制链接属性。</p>
<h2 id="六、结"><a href="#六、结" class="headerlink" title="六、结"></a>六、结</h2><p>存储类、作用域、生命周期和链接属性是相互关联的：<strong>存储类决定生命周期，作用域决定链接属性</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>存储类</th>
<th>作用域</th>
<th>生命周期</th>
<th>链接属性</th>
</tr>
</thead>
<tbody><tr>
<td>auto局部变量</td>
<td>stack</td>
<td>代码块</td>
<td>临时</td>
<td>无链接</td>
</tr>
<tr>
<td>static局部变量</td>
<td>.data/bss</td>
<td>代码块</td>
<td>永久</td>
<td>无链接</td>
</tr>
<tr>
<td>全局变量</td>
<td>.data/bss</td>
<td>文件</td>
<td>永久</td>
<td>外链接</td>
</tr>
<tr>
<td>函数</td>
<td>.text</td>
<td>文件</td>
<td>永久</td>
<td>外链接</td>
</tr>
<tr>
<td>inline函数</td>
<td>.text</td>
<td>文件</td>
<td>永久</td>
<td>无链接</td>
</tr>
<tr>
<td>static全局变量</td>
<td>.data/bss</td>
<td>文件</td>
<td>永久</td>
<td>内链接</td>
</tr>
<tr>
<td>static函数</td>
<td>.data/bss</td>
<td>文件</td>
<td>永久</td>
<td>内链接</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li><code>static</code>局部变量的地址由运行时环境在加载程序时确定，整个程序运行过程中唯一不变。</li>
<li>静态局部变量其实就是作用域为代码块作用域且无连接的全局变量</li>
<li>写程序尽量避免使用全局变量，尤其是非<code>static</code>类型的全局变量。能确定不会被其他文件引用的全局变量一定要<code>static</code>修饰</li>
<li>宏和<code>inline</code>函数的链接属性为无链接</li>
<li>为了避免<code>.h</code>文件被多个<code>.c</code>文件包含时全局变量重复定义的问题，全局变量应该定义在<code>.c</code>文件中并且在<code>.h</code>文件中声明</li>
<li>在<code>b.c</code>中引用<code>a.c</code>中定义的全局变量/函数有2种方法：<blockquote>
<ol>
<li>在<code>a.h</code>中声明该函数/全局变量，然后在<code>b.c</code>中<code>#include &lt;a.h&gt;</code></li>
<li>在<code>b.c</code>中使用<code>extern</code>显式声明要引用的函数/全局变量</li>
</ol>
<ul>
<li>其中第一种方法比较正式。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">C</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">存储类</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">作用域</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">生命周期</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">链接属性</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/12/%E5%AD%98%E5%82%A8%E7%B1%BB%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
    <article id="post-Makefile大法" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/11/Makefile%E5%A4%A7%E6%B3%95/">【Makefile】Makefile基本使用</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/11/Makefile%E5%A4%A7%E6%B3%95/" class="archive-article-date">
  	<time datetime="2020-02-11T11:39:49.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-11</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <h2 id="一、Makefile的引入"><a href="#一、Makefile的引入" class="headerlink" title="一、Makefile的引入"></a>一、Makefile的引入</h2><h3 id="1-1-用途"><a href="#1-1-用途" class="headerlink" title="1.1 用途"></a>1.1 用途</h3><p><code>Makefile</code>是用来管理工程的，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，<code>Makefile</code>定义了一系列的规则来指定，哪些文件先编译、后编译、重新编译，甚至于进行更复杂的功能操作。总而言之，<code>Makefile</code>方便编译链接过程，一旦写好，只需要一个<code>make</code>命令，整个工程完全自动编译链接，极大地提高了项目开发的效率。</p>
<h3 id="1-2-文件名"><a href="#1-2-文件名" class="headerlink" title="1.2 文件名"></a>1.2 文件名</h3><p><code>Makefile</code>常用的合法文件名有两个，一级文件夹里面有且只能有一个<code>Makefile</code></p>
<blockquote>
<ol>
<li><code>Makefile</code></li>
<li><code>makefile</code></li>
</ol>
</blockquote>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/makefile1.png" alt="makefile1"></p>
<h3 id="1-3-规则"><a href="#1-3-规则" class="headerlink" title="1.3 规则"></a>1.3 规则</h3><blockquote>
<ul>
<li><strong>目标</strong>：目标顶格写，后面是冒号（冒号后面是依赖）</li>
<li><strong>依赖</strong>：依赖是用来产生目标的原材料（可不写）</li>
<li><strong>命令</strong>：命令是要生成目标的加工方法，<strong>前面一定是<code>Tab</code>，不能顶格，也不能多个空格</strong>。<br>用空格代替<code>Tab</code>会报如下错误：<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/error1.png" alt="error1"></li>
</ul>
</blockquote>
<h4 id="1-3-1-参考片段"><a href="#1-3-1-参考片段" class="headerlink" title="1.3.1 参考片段"></a>1.3.1 参考片段</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">preprocess: a.c b.c</span></span><br><span class="line">		gcc -E a.c -o a.i</span><br><span class="line">		gcc -E b.c -o b.i</span><br><span class="line"></span><br><span class="line"><span class="section">compile: a.i b.i</span></span><br><span class="line">		gcc a.i b.i -o ab.exe</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm ab.exe</span><br></pre></td></tr></table></figure>

<h2 id="二、Makefile工作命令"><a href="#二、Makefile工作命令" class="headerlink" title="二、Makefile工作命令"></a>二、Makefile工作命令</h2><p><code>Makefile</code>在工作的时候有两种方式:<code>make 目标</code>和直接<code>make</code>，执行时默认先在终端打印将要执行的命令，然后执行。测试文件及内容如下：<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/clipboard_20200211091845.png" alt="clipboard_20200211091845.png"></p>
<h3 id="2-1-make-目标"><a href="#2-1-make-目标" class="headerlink" title="2.1 make 目标"></a>2.1 <code>make 目标</code></h3><blockquote>
<ul>
<li>如果写了依赖，<code>Makefile</code>会先检测依赖是否存在，如果依赖成立就执行下面的命令，不成立就停止执行</li>
<li>如果没写依赖，直接执行后面的命令，由编译工具链先进行是否合法的判断。</li>
</ul>
</blockquote>
<p>如下所示：<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/clipboard_20200211085900.png" alt="clipboard_20200211085900.png"></p>
<h3 id="2-2-直接-make"><a href="#2-2-直接-make" class="headerlink" title="2.2 直接 make"></a>2.2 直接 <code>make</code></h3><p>直接使用<code>make</code>命令的话，其默认目标就是第一个目标，如下所示：<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/3.png" alt="3.png"></p>
<h3 id="2-3-静默执行"><a href="#2-3-静默执行" class="headerlink" title="2.3 静默执行"></a>2.3 静默执行</h3><p>从前面我们可以看到，<code>Makefile</code>在执行命令的时候会先把命令先打印在终端上，如果不想看到命令本身，只想看到命令的执行结果，可以直接在命令前加<code>@</code>，采用<strong>静默执行</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">compile: a.c b.c</span></span><br><span class="line">		@gcc a.c b.c -o ab.exe</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm ab.exe</span><br></pre></td></tr></table></figure>

<p>如下所示，我们可以看到加了<code>@</code>之后就不会再显示命令了<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/clipboard_20200211102232.png" alt="clipboard_20200211102232.png"></p>
<h3 id="2-4-命令的显示与禁止"><a href="#2-4-命令的显示与禁止" class="headerlink" title="2.4 命令的显示与禁止"></a>2.4 命令的显示与禁止</h3><p>在执行<code>make</code>时带参数<code>-n</code>或<code>--just-print</code>，那么只显示命令但不会执行，这个功能有利于调试<code>Makefile</code>;<br>而参数<code>-s</code>或<code>--slient</code>则是全面禁止命令的显示，只执行命令，如下所示：</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/clipboard_20200211112456.png" alt="clipboard_20200211112456.png"></p>
<h2 id="三、伪目标（-PHONY）"><a href="#三、伪目标（-PHONY）" class="headerlink" title="三、伪目标（.PHONY）"></a>三、伪目标（.PHONY）</h2><ul>
<li>伪目标意思是这个目标本身不代表一个文件，执行目标不是为了得到文件，而是单纯为了执行这个目标下面的命令。一般<code>clean</code>用伪目标</li>
<li>伪目标一般没有依赖，既然是为了执行命令就不必加依赖，因为不加依赖意思就是无条件执行。</li>
<li>伪目标可以直接写，不影响使用；为了明确声明这个目标是伪目标会在其前面用<code>.PHONY</code>来明确声明它是伪目标</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm ab.exe</span><br></pre></td></tr></table></figure>

<h2 id="四、使用变量"><a href="#四、使用变量" class="headerlink" title="四、使用变量"></a>四、使用变量</h2><p>在<code>Makefile</code>中，一个命令如果有很多<code>.c</code>之类的文件，将不便于修改，此时可以采用变量的形式。</p>
<h3 id="4-1-使用规则"><a href="#4-1-使用规则" class="headerlink" title="4.1 使用规则"></a>4.1 使用规则</h3><p><code>Makefile</code>中的变量都没有变量类型，直接定义使用，引用变量时用<code>$(变量名)</code>。变量在引用时类似于<code>C</code>语言的宏，也是原地展开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var &#x3D; a.c b.c</span><br><span class="line"></span><br><span class="line">compile: $(var)</span><br><span class="line">		@gcc $(var) -o ab.exe</span><br></pre></td></tr></table></figure>

<p>可以用<code>echo</code>打印变量信息，如下所示:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">print:</span></span><br><span class="line">		echo <span class="variable">$(var)</span></span><br></pre></td></tr></table></figure>

<p>结果如下<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/clipboard_20200211105500.png" alt="clipboard_20200211105500.png"></p>
<h3 id="4-2-几种变量赋值运算符"><a href="#4-2-几种变量赋值运算符" class="headerlink" title="4.2 几种变量赋值运算符"></a>4.2 几种变量赋值运算符</h3><h4 id="4-2-1-与"><a href="#4-2-1-与" class="headerlink" title="4.2.1 =与:="></a>4.2.1 <code>=</code>与<code>:=</code></h4><blockquote>
<ul>
<li>使用<code>=</code> 赋值时变量的值可以定义在文件的任何一处，不一定非要是已定义好的值，可以使用后面定义的值，在解析时使用最后定义的值</li>
<li>使用<code>:=</code>赋值时前面的变量不会使用后面的变量，只能使用前面已定义好了的变量</li>
</ul>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var1 = abcd</span><br><span class="line">var3 := abcd</span><br><span class="line">var2 := <span class="variable">$(var1)</span></span><br><span class="line">var4 = <span class="variable">$(var3)</span></span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">		echo var1 的值为 <span class="variable">$(var1)</span></span><br><span class="line">		echo var2 的值为 <span class="variable">$(var2)</span></span><br><span class="line">		echo var3 的值为 <span class="variable">$(var3)</span></span><br><span class="line">		echo var4 的值为 <span class="variable">$(var4)</span></span><br><span class="line"></span><br><span class="line">var1 = efgh</span><br><span class="line">var3 := efgh</span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/clipboard_20200211113950.png" alt="clipboard_20200211113950.png"><br>我们可以看到：</p>
<blockquote>
<ul>
<li>虽然<code>var1</code>是用<code>=</code>赋值的，但是<code>var2</code>是用<code>:=</code>赋值的，<code>var2</code>在对<code>$(var1)</code>进行解析时只会查看<code>var2</code>前面的语句</li>
<li>而<code>var4</code>解析<code>$(var3)</code>是会查看整个文件，即使<code>var3</code>采用的是<code>:=</code>赋值；</li>
<li>直接对变量进行解析打印时，不管是<code>=</code>赋值还是<code>:=</code>赋值，最后打印的都是最后的值，也就是说解析最后的值</li>
</ul>
</blockquote>
<h4 id="4-2-2"><a href="#4-2-2" class="headerlink" title="4.2.2 ?="></a>4.2.2 <code>?=</code></h4><p><code>var ?= bar</code>的含义是：如果<code>var</code>没有被定义过，那么变量<code>var</code>的值就是<code>bar</code>，如果<code>var</code>先前被定义过，那么这条语将什么也不做。</p>
<h4 id="4-2-3"><a href="#4-2-3" class="headerlink" title="4.2.3 +="></a>4.2.3 <code>+=</code></h4><p>用来给一个已经赋值的变量接续赋值，有点类似于<code>C</code>语言中的<code>strcat</code>。需要注意的是<code>+=</code><strong>续接的内容和原来的内容之间会自动加一个空格隔开</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object := a.c b.c c.c</span><br><span class="line">object += d.c</span><br><span class="line"></span><br><span class="line"><span class="section">printf: <span class="variable">$(object)</span></span></span><br><span class="line">		echo <span class="variable">$(object)</span></span><br></pre></td></tr></table></figure>

<p>结果如图所示：<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/clipboard_20200212121713.png" alt="clipboard_20200212121713.png"></p>
<h2 id="五、通配符"><a href="#五、通配符" class="headerlink" title="五、通配符"></a>五、通配符</h2><h3 id="5-1-与"><a href="#5-1-与" class="headerlink" title="5.1 *,?与[]"></a>5.1 <code>*</code>,<code>?</code>与<code>[]</code></h3><p>如果要处理一系列比较类似的文件，我们可以使用以下三种通配符：</p>
<blockquote>
<ol>
<li><code>*</code> 若干个任意字符</li>
<li><code>?</code> 一个任意字符</li>
<li><code>[]</code>将[]中的字符依次去和外面的结合匹配</li>
</ol>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.PHNOY:clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm -f *.c [abcd].h a?cd.c</span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/clipboard_20200212011451.png" alt="clipboard_20200212011451.png"><br>如图所示，我们有一串文件夹，在clean的过程中：</p>
<blockquote>
<ul>
<li><code>a.c b.c c.c d.c</code>均匹配<code>*.c</code>，故被删除</li>
<li><code>a.h b.h c.h d.h</code>与<code>[abcd].h</code>匹配，由于字符依次匹配，故<code>ab.h</code>扔保留</li>
</ul>
</blockquote>
<h3 id="5-2-规则通配符-和自动推导"><a href="#5-2-规则通配符-和自动推导" class="headerlink" title="5.2 规则通配符%和自动推导"></a>5.2 规则通配符<code>%</code>和自动推导</h3><p>还有一个和<code>*</code>看似很像的通配符%，<code>%</code>代表一个或几个字母，比如<code>%.o</code>就代表所有以<code>.o</code>为结尾的文件。但是<code>%</code>和<code>*</code>作用是不同的，<code>%</code>作为规则通配符常用在<code>Makefile</code>的自动推导上。所谓自动推导其实就是当<code>Makefile</code>需要某一个目标时，他会把这个目标去套规则说明，一旦套上了某个规则说明，<code>Makefile</code>就会去寻找这个规则中的依赖，如果能找到则会执行这个规则用依赖生成目标。</p>
<h3 id="5-3-自动变量"><a href="#5-3-自动变量" class="headerlink" title="5.3 自动变量"></a>5.3 自动变量</h3><p>在有些情况下文件集合中文件非常多，描述的时候很麻烦，<code>Makefile</code>就用一些特殊的符号来替代符合某种条件的文件集，这就形成了自动变量。自动变量是预定义的特殊意义的符号，就类似于<code>C</code>语言编译器中预制的<code>__FILE__</code>宏，常见自动变量有以下三种：</p>
<blockquote>
<ol>
<li><code>$@</code> :规则的目标文件名</li>
<li><code>$&lt;</code> :规则的依赖文件名</li>
<li><code>$^</code> :依赖的文件集合</li>
</ol>
</blockquote>
<h3 id="5-4-测试脚本及结果"><a href="#5-4-测试脚本及结果" class="headerlink" title="5.4 测试脚本及结果"></a>5.4 测试脚本及结果</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">abcd.elf: a.o b.o c.o d.o</span></span><br><span class="line">		gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#$^为a.o b.o c.o d.o，$@为abcd.elf</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.i</span></span><br><span class="line">		gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.i: %.c</span></span><br><span class="line">		gcc -E <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/Makefile/clipboard_20200212013835.png" alt="clipboard_20200212013835.png"><br>在执行命令<code>make abcd.elf</code>时，需要一系列.o的依赖，这个时候makefile由.o推到.i，再由.i推到.c</p>
<h2 id="六、Makefile的环境变量"><a href="#六、Makefile的环境变量" class="headerlink" title="六、Makefile的环境变量"></a>六、Makefile的环境变量</h2><ul>
<li><code>Makefile</code>中用<code>export</code>导出的就是环境变量，一般情况下环境变量名用大写，普通变量名用小写。环境变量类似于整个工程中所有<code>Makefile</code>之间可以共享的全局变量，定义了一个环境变量会影响到工程中别的<code>Makefile</code>文件，因此要小心。</li>
<li><code>Makefile</code>中有一些环境变量可能是<code>Makefile</code>本身自己定义的内部环境变量或者是当前的执行环境提供的环境变量（如命令<code>make CC=arm-linux-gcc</code>，其实就是给当前<code>Makefile</code>传了一个环境变量<code>CC</code>，值是<code>arm-linux-gcc</code>。在<code>make</code>时给<code>Makefile</code>传的环境变量值优先级最高的，可以覆盖<code>makefile</code>中的赋值）</li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">Makefile</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/11/Makefile%E5%A4%A7%E6%B3%95/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
    <article id="post-动态链接库与静态链接库" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/11/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/">【C语言】静态链接库与动态链接库的制作与使用</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/11/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" class="archive-article-date">
  	<time datetime="2020-02-11T08:51:49.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-11</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <h2 id="一、函数库简述"><a href="#一、函数库简述" class="headerlink" title="一、函数库简述"></a>一、函数库简述</h2><p>简单来说，函数库就是一些事先写好的模块化的函数的集合，可以供给其他程序员使用。最开始没有函数库，每个程序员写程序都要从零开始写，时间长了慢慢地就积累下来了一些优质的函数库。后来有组织把各种函数库收拢在一起，经过校准和整理，形成一份标准化的函数库，就是现在的标准的函数库，如<code>glibc</code></p>
<h3 id="1-1-函数库的提供形式：动态链接库与静态链接库"><a href="#1-1-函数库的提供形式：动态链接库与静态链接库" class="headerlink" title="1.1 函数库的提供形式：动态链接库与静态链接库"></a>1.1 函数库的提供形式：动态链接库与静态链接库</h3><p>早期的函数共享都是以源代码的形式进行的，慢慢地，源码共享的方向就形成了我们现在的开源社区，无法以商业化形式来发布函数库。商业公司需要将自己的函数库让他人付费使用，但是又不能给客户源代码，这时候就出现了静态链接库和动态链接库。</p>
<h4 id="1-1-1-静态链接库"><a href="#1-1-1-静态链接库" class="headerlink" title="1.1.1 静态链接库"></a>1.1.1 静态链接库</h4><p>商业公司将函数库源代码经过只编译不连接形成<code>.o</code>的目标文件，然后用<code>ar</code>工具将<code>.o</code>文件归档成<code>.a</code>的归档文件，这个<code>.a</code>的归档文件就叫做静态链接库文件。通过发布<code>.a</code>库文件和<code>.h</code>头文件来提供静态库给客户使用；</p>
<p>客户拿到<code>.a</code>和<code>.h</code>文件后，通过<code>.h</code>头文件得知库中的库函数的原型，然后在自己的<code>.c</code>文件中直接调用这些库文件，在链接的时候链接器会去<code>.a</code>文件中拿出被调用的那个函数的编译后的<code>.o</code>二进制代码段链接进去形成最终的可执行程序。</p>
<h4 id="1-1-2-动态链接库"><a href="#1-1-2-动态链接库" class="headerlink" title="1.1.2 动态链接库"></a>1.1.2 动态链接库</h4><p>动态库比静态链接库出现得晚一些，效率更高一些。<strong>现在一般都是使用动态库</strong>。静态库在用户链接自己的可执行程序时就已经把调用的库中的函数的代码段链接进最终可执行程序中了，这样好处是随处可以执行，坏处是太占地方了。尤其是有多个应用程序都使用了同一个库函数时，最后生成的可执行程序中都各自有一份这个库函数的代码段。当这些应用程序同时在内存中运行时，实际上在内存中有多个这个库函数的代码段，这完全重复了。</p>
<p>而<strong>动态链接库本身不将库函数的代码段链接入可执行程序，只是做个标记</strong>。然后当应用程序在内存中执行时，运行时环境发现它调用了一个动态库中的库函数时，会去加载这个动态库到内存中，然后以后不管有多少个应用程序去调用这个库中的函数都会跳转到第一次加载的地方去执行（不会重复加载）。</p>
<h3 id="1-2-函数库中库函数的使用"><a href="#1-2-函数库中库函数的使用" class="headerlink" title="1.2 函数库中库函数的使用"></a>1.2 函数库中库函数的使用</h3><ol>
<li><code>gcc</code>中编译链接程序默认使用动态库，要静态链接需要显式用<code>-static</code>来强制静态链接。</li>
<li>库函数的使用需要注意:<blockquote>
<ol>
<li>包含相应的头文件</li>
<li>调用库函数时注意函数原型</li>
<li>有些库函数链接时需要额外用<code>-lxxx</code>来指定链接</li>
<li>如果不是系统库，要注意用<code>-L</code>指定库的地址</li>
</ol>
</blockquote>
</li>
</ol>
<p>如我们使用数学函数库中的<code>sqrt</code>函数:</p>
<blockquote>
<ol>
<li>真正的数学运算的函数定义在：<code>/usr/include/x86_64-linux-gnu/bits/mathcalls.h</code></li>
<li>使用数学库函数的时候，只需要包含<code>math.h</code>即可</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">16.0</span>;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"y = %lf\n"</span>, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学过C语言的同学都知道答案是<code>4.000000</code>，但是直接编译的结果是什么呢？看下图：<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212120431.png" alt="clipboard_20200212120431.png"><br>我们会发现在链接的时候报错了！报的是对<code>&#39;sqrt&#39;</code>未定义的引用，即sqrt函数有声明(在<code>math.h</code>中)有引用(在<code>math.c</code>)，但是没有定义，链接器找不到函数体。为什么会这样呢？因为库函数有很多，链接器去库函数目录搜索的时间比较久。为了提升速度链接器只是默认地寻找几个最常用的库，如果是一些不常用的库中的函数被调用，需要程序员在链接时明确给出要扩展查找的库的名字。<br><strong>链接时可以用-lxxx来指示链接器去到libxxx.a(静)或libxxx.so(动)中去查找函数</strong><br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212010335.png" alt="clipboard_20200212010335.png"><br>我们可以看到加了<code>-lm</code>后就成功链接了，同时，我们也可以看到静态链接比动态链接生成的可执行文件的大小根本不在同一个数量级！！！</p>
<h2 id="二、制作并使用静态链接库"><a href="#二、制作并使用静态链接库" class="headerlink" title="二、制作并使用静态链接库"></a>二、制作并使用静态链接库</h2><h3 id="2-1-制作"><a href="#2-1-制作" class="headerlink" title="2.1 制作"></a>2.1 制作</h3><p>创建对应的<code>.c源文件</code>和<code>.h头文件</code>以及<code>Makefile</code>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch mylib1.c mylib1.h Makefile</span><br></pre></td></tr></table></figure>

<p>编辑好头文件和源文件的对应内容，如图所示：<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212012726.png" alt="clipboard_20200212012726.png"></p>
<p>接下来先只编译不连接，生成<code>.o</code>文件；然后使用<code>ar</code>工具进行打包成<code>.a</code>归档文件，打包时注意库名不能随便乱起，一般是<code>lib+库名称</code>，后缀名<code>.a</code>表示是静态链接库文件。对应的<code>Makefile</code>段如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">lib:</span></span><br><span class="line">	gcc -c mylib1.c -o mylib1.o</span><br><span class="line">	ar -rc libmylib1.a mylib1.o</span><br></pre></td></tr></table></figure>

<p>执行对应的脚本即可完成静态库的制作<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212013750.png" alt="clipboard_20200212013750.png"></p>
<h3 id="2-2-发布"><a href="#2-2-发布" class="headerlink" title="2.2 发布"></a>2.2 发布</h3><p>所谓发布，就是将<code>.a</code>文件和<code>.h</code>文件放在一个独立的文件夹里面，以便后续使用。如图所示<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212020007.png" alt="clipboard_20200212020007.png"></p>
<h3 id="3-3-使用"><a href="#3-3-使用" class="headerlink" title="3.3 使用"></a>3.3 使用</h3><p>我们在发布的文件夹里建立自己的<code>.c</code>文件，就可以直接调用库函数了！</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch main.c Makefile</span><br></pre></td></tr></table></figure>

<p>我们在主函数中添加如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mylib1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myprint();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>1.2</code>使用数学函数的时候我们知道链接器只会去器寻找几个最常用的库，我们发布的库肯定不会被寻找的，所以需要加<code>-lxxx</code>去指定</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">	gcc main.c -o main.elf -lmylib1</span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212021729.png" alt="clipboard_20200212021729.png"><br>我们会发现，这样还是不能正确链接，会有如下报错信息：<code>/usr/bin/ld: 找不到 -lmylib1</code>，通过报错信息我们知道，链接器默认只在系统指定的目录下寻找链接库。所以需要用-L指定库的地址，我们将Makefile修改如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">	gcc main.c -o main.elf -lmylib1 -L.</span><br></pre></td></tr></table></figure>

<p>其中<code>.</code>就表示在当前目录下，我们可以看到程序进行了成功地编译链接<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212024628.png" alt="clipboard_20200212024628.png"></p>
<h2 id="三、制作并使用动态链接库"><a href="#三、制作并使用动态链接库" class="headerlink" title="三、制作并使用动态链接库"></a>三、制作并使用动态链接库</h2><h3 id="3-1-制作与发布"><a href="#3-1-制作与发布" class="headerlink" title="3.1 制作与发布"></a>3.1 制作与发布</h3><p>动态链接库的制作和静态库思路类似，只是后缀名是<code>.so</code>(<code>windows</code>下是<code>dll</code>)，通过<code>gcc</code>来打包而不是<code>ar</code>，对应的<code>Makefile</code>如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">lib:</span></span><br><span class="line">	gcc -c mylib2.c -o mylib2.o -fPIC</span><br><span class="line">	gcc mylib2.o -o libmylib2.so -shared</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<blockquote>
<ul>
<li><code>-fPIC</code>是位置无关码，作用于编译阶段，告诉编译器产生与位置无关的代码<code>(Position-Independent Code)</code>。即产生的代码中，没有绝对地址，全部使用相对地址，被加载器加载到内存的任意位置，都可以正确执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</li>
<li><code>-shared</code>是按照共享库的方式来链接</li>
</ul>
</blockquote>
<p>发布的时候发布<code>libxxx.so</code>和<code>xxx.h</code>即可，这里不再赘述</p>
<h3 id="3-2-使用"><a href="#3-2-使用" class="headerlink" title="3.2 使用"></a>3.2 使用</h3><p>有了静态库的经验我们知道，编译链接时的指令应该是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">	gcc main.c -o main.elf -lmylib2 -L.</span><br></pre></td></tr></table></figure>

<p>我们可以看到程序被成功编译链接了<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212030923.png" alt="clipboard_20200212030923.png"><br>但是运行出错，报错信息：<code>error while loading shared libraries: libmylib2.so: cannot open shared object file: No such file or directory</code></p>
<p>这是因为<strong>动态链接库运行时需要被加载</strong>(运行时环境在执行程序的时候发现动态链接了<code>libxxx. so</code>，于是会去<strong>固定目录<code>/usr/lib</code>下加载libxxx. so</strong>，如果加载失败则会打印以上错误信息。）</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li><strong>将libaston.so放到固定目录/usr/lib下</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp libmylib2.so /usr/lib</span><br></pre></td></tr></table></figure>

<p>一般而言固定目录<code>/usr/lib</code>用来存放系统自带的动态链接库，不建议用户自行修改里面的内容</p>
<ol start="2">
<li><strong>使用环境变量LD_LIBRARY_PATH</strong></li>
</ol>
<p>操作系统在加载固定目录<code>/usr/lib</code>之前，会先去<code>LD_LIBRARY_PATH</code>这个环境变量所指定的目录下去寻找，如果找到则不去<code>/usr/lib</code>目录下，如果没找到再去<code>/usr/lib</code>下。所以可将<code>libaston.so</code>所在的目录导出到环境变量<code>LD_LIBRARY_PATH</code>中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=D_LIBRARY_PATH:\</span><br><span class="line">/mnt/hgfs/VMShare/C/<span class="number">6.</span>PreprocessFunction/funclib/dynamiclib/publib</span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212033449.png" alt="clipboard_20200212033449.png"><br>我们可以发现，导入环境变量之后程序就可以直接运行了</p>
<h3 id="3-3-ldd命令"><a href="#3-3-ldd命令" class="headerlink" title="3.3 ldd命令"></a>3.3 ldd命令</h3><p><code>ldd</code>命令可以在一个使用了共享库的程序执行之前解析出这个程序使用了哪些共享库，并且查看这些共享库是否能被找到，如上述示例加入了共享库后，使用了的所有的<code>.so</code>都能被解析到地址<br><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212033923.png" alt="clipboard_20200212033923.png"><br>如果我们将环境变量设置为空：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=</span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/Func/clipboard_20200212034333.png" alt="clipboard_20200212034333.png"><br>我们可以看到<code>main.elf</code>链接的<code>libmylib2.so</code>处于<code>not found</code>状态，故无法正确执行</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">C</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">函数库</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/11/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
    <article id="post-C语言宏定义与预处理" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/09/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/">【C语言】宏定义与预处理</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/09/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/" class="archive-article-date">
  	<time datetime="2020-02-09T12:07:49.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-09</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <h2 id="一、由源码到可执行程序的过程"><a href="#一、由源码到可执行程序的过程" class="headerlink" title="一、由源码到可执行程序的过程"></a>一、由源码到可执行程序的过程</h2><p><strong>1. 预处理：</strong> 源码经过预处理器的预处理变成预处理过的<code>.i</code>中间文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<p><strong>2. 编译：</strong> 中间文件经过编译器编译形成<code>.s</code>的汇编文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>

<p><strong>3. 汇编：</strong> 汇编文件经过汇编器生成目标文件<code>.o</code>(机器语言)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>

<p><strong>4. 链接：</strong> 链接器将目标文件链接成<code>.exe</code>可执行程序(<code>Linux</code>下是<code>.elf</code>)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o test.exe</span><br></pre></td></tr></table></figure>

<p>在整个过程中，预处理用预处理器，编译用编译器，汇编用汇编器，链接用链接器，这几个工具再加上其他额外的可能会用到的工具，合起来叫<strong>编译工具链</strong>。<code>gcc/g++</code>就是一个编译工具链，在实际工程中并不会去手动生成那么多中间文件，而是直接一步到位：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test.exe</span><br></pre></td></tr></table></figure>

<p>其中，编译器的主要目的是编译源代码，即将<code>.c</code>的源代码（<code>.i</code>本质上就是预处理过的<code>.c</code>)转化成<code>.s</code>汇编代码。为了让编译器聚焦核心功能，就将一些非核心功能剥离到预处理器去了，也就是所让预处理器帮编译器做一些编译前的准备工作。</p>
<h2 id="二、编程中常见的预处理"><a href="#二、编程中常见的预处理" class="headerlink" title="二、编程中常见的预处理"></a>二、编程中常见的预处理</h2><blockquote>
<ol>
<li>头文件包含：<code>#include</code></li>
<li>注释</li>
<li>条件编译：<code>#if #elif #endif...</code></li>
<li>宏定义</li>
</ol>
</blockquote>
<h3 id="2-1-头文件包含"><a href="#2-1-头文件包含" class="headerlink" title="2.1 头文件包含"></a>2.1 头文件包含</h3><h4 id="2-1-1-include-lt-gt-和-include-quot-quot-的区别"><a href="#2-1-1-include-lt-gt-和-include-quot-quot-的区别" class="headerlink" title="2.1.1 #include &lt;&gt;和 #include &quot;&quot;的区别"></a>2.1.1 <code>#include &lt;&gt;</code>和 <code>#include &quot;&quot;</code>的区别</h4><blockquote>
<ul>
<li><code>#include &lt;&gt;</code>专门用来包含系统提供的头文件，如果使用<code>&lt;&gt;</code>，编译器只会到系统指定目录(编译器中配置的或<code>OS</code>配置的目录，如在<code>Ubuntu</code>中是<code>/usr/include</code>，编译器还允许用<code>-I</code>来附加指定其他的包含路径)去寻找这个头文件，如果找不到就会提示这个头文件不存在。</li>
<li><code>#include &quot;&quot;</code>用来包含程序员写的头文件，编译器默认先在当前目录下寻找相应的头文件，如果没找到再到系统指定目录去寻找，如果还没找到则提示文件不存在。</li>
</ul>
</blockquote>
<h5 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h5><blockquote>
<ul>
<li>系统自带的用<code>&lt;&gt;</code></li>
<li>程序员写的放在当前目录下用<code>&quot;&quot;</code></li>
<li>程序员写的集中放专门存放头文件的目录下，在编译器中用<code>-I</code>参数寻找用<code>&lt;&gt;</code></li>
</ul>
</blockquote>
<h4 id="2-1-2-头文件包含在预处理时的处理方式"><a href="#2-1-2-头文件包含在预处理时的处理方式" class="headerlink" title="2.1.2 头文件包含在预处理时的处理方式"></a>2.1.2 头文件包含在预处理时的处理方式</h4><p>在预处理的时候，预处理器将所包含的头文件的内容原处展开替换这<code>#include</code>语句。<br>如下所示分别是同一目录下的<code>.c</code>文件和<code>.h</code>文件：</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/%E5%AE%8F%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/test1.png" alt="test1.png"></p>
<p>对其进行预编译生成<code>.i</code>文件后，<code>.i</code>文件的内容如下所示：</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/%E5%AE%8F%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/test2.png" alt="test2.png"></p>
<h3 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h3><p>我们在<code>.c</code>源文件中写的注释，预处理器在预处理阶段会将其擦除(在<code>.c</code>文件依然存在，在<code>.i</code>文件中不存在)。其实这也正顺应了注释是写给使用程序的人看的，而不是给编译器看的。如下所示：</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/%E5%AE%8F%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/test.3.png" alt="test.3.png"></p>
<h3 id="2-3-条件编译"><a href="#2-3-条件编译" class="headerlink" title="2.3 条件编译"></a>2.3 条件编译</h3><p>一般情况下，源程序中所有行都参与编译，但有时希望程序有多种配置，对一部分内容指定编译条件(如产品的调试版与正式版)，这就是<strong>条件编译</strong><code>(conditional compile)</code>，条件编译有以下两种判定方法：</p>
<h4 id="2-3-1-if"><a href="#2-3-1-if" class="headerlink" title="2.3.1 #if"></a>2.3.1 #if</h4><p>这种判定方法类似于<code>if...else...</code>语句，格式为<code>#if (条件表达式)</code>，它的判定标准是()中的表达式是<code>true</code>还是<code>flase</code>，在进行预编译的过程中，只会保留条件表达式为真的那部分内容，如下所示测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span>(DEBUG == 1)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Version: DEBUG!"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">elif</span>(DEBUG == 2)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Version: TEST!"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Version: LAST!"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预编译结果如下所示：</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/%E5%AE%8F%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/test4.png" alt="test4.png"></p>
<p>我们也可以不在源码中对<code>DEBUG</code>进行宏定义，而在编译的时候可以用如下方法对其进行宏定义并指定值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E -D DEBUG=<span class="number">2</span> test.c -o test.i</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/%E5%AE%8F%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/test5.png" alt="test5.png"></p>
<h4 id="2-3-2-ifdef"><a href="#2-3-2-ifdef" class="headerlink" title="2.3.2 #ifdef"></a>2.3.2 #ifdef</h4><p>用<code>#ifdef XXX</code>判定条件成立与否时主要是看<code>XXX</code>这个符号在本语句之前有没有被定义，只要定义了，判断就成立，并不关心<code>XXX</code>的宏值为多少。测试代码及结果参见下文<strong>3.1非带参宏</strong>的内容</p>
<h2 id="三、宏定义"><a href="#三、宏定义" class="headerlink" title="三、宏定义"></a>三、宏定义</h2><h3 id="3-1-非带参宏"><a href="#3-1-非带参宏" class="headerlink" title="3.1 非带参宏"></a>3.1 非带参宏</h3><p>非带参宏主要结合条件编译使用，比较简单，其定义格式为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 替换列表(替换列表可有可无)</span></span><br></pre></td></tr></table></figure>

<p>如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST2 TEST</span></span><br></pre></td></tr></table></figure>

<h4 id="宏定义的预处理"><a href="#宏定义的预处理" class="headerlink" title="宏定义的预处理"></a>宏定义的预处理</h4><blockquote>
<ol>
<li>在预处理阶段由预处理器进行<strong>机械替换</strong>，而不做类型检查</li>
<li>宏定义替换会递归进行，直到替换出来的值本身不再是一个宏为止</li>
</ol>
</blockquote>
<p>如下是在<code>STM32</code>开发过程中常用的打印调试信息的一个调试代码段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_TIMER_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USER_TIMER_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_printf(format, ...)  printf( format <span class="meta-string">"\r\n"</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_info(format, ...)  printf(<span class="meta-string">"[\ttimer]info:"</span> format <span class="meta-string">"\r\n"</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_debug(format, ...) printf(<span class="meta-string">"[\ttimer]debug:"</span> format <span class="meta-string">"\r\n"</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_error(format, ...) printf(<span class="meta-string">"[\ttimer]error:"</span> format <span class="meta-string">"\r\n"</span>,##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_printf(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_info(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_debug(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> user_timer_error(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>预编译结果如图所示：</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/%E5%AE%8F%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/test6.png" alt="test6.png"></p>
<h3 id="3-2-带参宏"><a href="#3-2-带参宏" class="headerlink" title="3.2 带参宏"></a>3.2 带参宏</h3><p>宏可以带参数，称为带参宏。带参宏的使用和带参函数非常相似，只是在使用上和处理上有一些差异，其定义格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符(参数1,参数2,...,参数n) 替换列表</span></span><br></pre></td></tr></table></figure>

<p>在定义带参宏时，<strong>每一个参数在宏体中引用时都必须加括号，最后整体再加括号，括号缺一不可</strong>。</p>
<p>不带括号的后果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M(a, b) a * b</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = M(<span class="number">2</span> + <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上测试代码，我们想得到<code>(2 + 3) * 5</code>的结果，但是由于宏在预处理的时候也是进行机械替换，<code>int result = M(2 + 3, 5)</code>变成了<code>int result = 2 + 3 * 5</code>，这及其容易出现逻辑上的错误</p>
<h4 id="3-2-1-带参宏示例"><a href="#3-2-1-带参宏示例" class="headerlink" title="3.2.1 带参宏示例"></a>3.2.1 带参宏示例</h4><p><strong>1.MAX宏:</strong> 求2个数中较大的一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (((a)&gt;(b)) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>

<p><strong>2.SEC_PER_YEAR宏</strong> 用宏定义表示一年中有多少秒</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC_PER_YEAR (365*24*60*60UL)</span></span><br></pre></td></tr></table></figure>

<p>这个宏需要注意的是</p>
<blockquote>
<ol>
<li>当一个数字直接出现在程序中时，它的是类型默认是<code>int</code></li>
<li>一年有多少秒，这个数字超过了<code>int</code>类型存储的范围</li>
<li>加<code>UL</code>将其转为无符长整型</li>
</ol>
</blockquote>
<h4 id="3-2-2-带参宏和带参函数的区别"><a href="#3-2-2-带参宏和带参函数的区别" class="headerlink" title="3.2.2 带参宏和带参函数的区别"></a>3.2.2 带参宏和带参函数的区别</h4><h5 id="1-时间与空间"><a href="#1-时间与空间" class="headerlink" title="1.时间与空间"></a>1.时间与空间</h5><blockquote>
<ul>
<li>宏定义在预处理期间处理，进行简单的内容替换，无需额外空间</li>
<li>函数是在编译期间处理的，调用时需要为形参分配空间并将实参的值赋给形参</li>
</ul>
</blockquote>
<h5 id="2-执行速度"><a href="#2-执行速度" class="headerlink" title="2.执行速度"></a>2.执行速度</h5><blockquote>
<ul>
<li>宏只进行文本替换，函数运行阶段参数需要进行出入栈的操作，速度比宏慢</li>
</ul>
</blockquote>
<h5 id="3-类型检查"><a href="#3-类型检查" class="headerlink" title="3.类型检查"></a>3.类型检查</h5><blockquote>
<ul>
<li>宏定义不会检查参数的类型，返回值也不会附带类型</li>
<li>而数有明确的参数类型和返回值类型。当调用函数时编译器参数的静态类型检查，如果编译器发现实际传参和参数声明不同时会报警告或错误。</li>
</ul>
</blockquote>
<h5 id="综合比较"><a href="#综合比较" class="headerlink" title="综合比较"></a>综合比较</h5><p>宏和函数各有千秋，最大的特点是：用函数的时候程序员不太用操心类型不匹配因为编译器会检查，用宏的时候程序员必须注意实际传参和宏所希望的参数类型一致，或者自行加入类型检查，否则可能编译不报错但是运行有误。</p>
<p>如对MAX宏加入类型检查：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (&#123;\</span></span><br><span class="line">typeof(a) _a = (a); \</span><br><span class="line">typeof(b) _b = (b); \</span><br><span class="line">(<span class="keyword">void</span>) (&amp;_a == &amp;_b);\</span><br><span class="line">_a &gt; _b ? _a : _b;&#125;)</span><br></pre></td></tr></table></figure>

<p>测试代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (&#123;\</span></span><br><span class="line">typeof(a) _a = (a); \</span><br><span class="line">typeof(b) _b = (b); \</span><br><span class="line">(<span class="keyword">void</span>) (&amp;_a == &amp;_b);\</span><br><span class="line">_a &gt; _b ? _a : _b;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX2(a, b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">3.1</span>;</span><br><span class="line">    <span class="keyword">int</span> result2 = MAX2(a, b);</span><br><span class="line">    typeof(MAX(a, b)) result = MAX(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %f\n"</span>, result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result2 = %d\n"</span>, result2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/%E5%AE%8F%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/test7.png" alt="test7.png"></p>
<h2 id="四、内联函数"><a href="#四、内联函数" class="headerlink" title="四、内联函数"></a>四、内联函数</h2><p>内联函数本质上是函数，通过在函数定义前加<code>inline</code>关键字实现，是编译器负责处理的，可以做参数的静态类型检查。同时也有带参宏的展开特性，运行时没有调用开销。</p>
<h3 id="4-1-与常规函数对比"><a href="#4-1-与常规函数对比" class="headerlink" title="4.1 与常规函数对比"></a>4.1 与常规函数对比</h3><blockquote>
<ul>
<li>当函数体很短的时候，使用常规函数会造成很大的调用开销,内联函数采用原地展开的方式，没有调用开销</li>
<li>当函数体长的时候，由于内联函数展开会降低寻址效率，所以长函数体不会使用内联函数</li>
<li>内联函数本质上是函数，函数的性质内联函数都有</li>
</ul>
</blockquote>
<h3 id="4-2-与宏的对比"><a href="#4-2-与宏的对比" class="headerlink" title="4.2 与宏的对比"></a>4.2 与宏的对比</h3><blockquote>
<ul>
<li>参数类型检查。编译过程中，编译器仍可以对其内联函数进行参数检查</li>
<li>便于调试。函数支持的调试功内联函数同样支持，而宏不支持</li>
<li>接口封装。有些内联函数可以用来封装一个接口，而宏不具备这个特性</li>
</ul>
</blockquote>
<h3 id="4-3-noinline和always-inline"><a href="#4-3-noinline和always-inline" class="headerlink" title="4.3 noinline和always_inline"></a>4.3 noinline和always_inline</h3><p>当函数的函数体很小，而且被大量频繁调用，应该做内联展开时，就可以使用内联函数。但编译器会不会作内联展开，编译器也会有自己的权衡（不合理的内联函数会降低<code>CPU</code>寻址效率、函数运行效率、降低代码的可移植性…）。如果想告诉编译器一定要展开，或者不作展开，就可以使用<code>noinline</code>或<code>always_inline</code>对函数作一个属性声明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;<span class="comment">//编译器权衡是否内联展开</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((noinline)) <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;<span class="comment">//不内联展开</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((always_inline)) <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;<span class="comment">//内联展开</span></span><br></pre></td></tr></table></figure>

<p>用<code>static</code>修饰呢是因为内联函数不一定会内联展开，当多个文件都包含同一个内联函数的定义时，如果没有<code>static</code>将函数的作用域限制在各自本地文件内，编译时就有可能报重定义错误</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">C</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">宏定义</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">预处理</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/09/C%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
    <article id="post-位操作实现置位与复位" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/09/%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E7%BD%AE%E4%BD%8D%E4%B8%8E%E5%A4%8D%E4%BD%8D/">【C语言】位运算实现置位与复位</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/09/%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E7%BD%AE%E4%BD%8D%E4%B8%8E%E5%A4%8D%E4%BD%8D/" class="archive-article-date">
  	<time datetime="2020-02-09T03:48:49.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-09</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <h2 id="一、常用位操作符"><a href="#一、常用位操作符" class="headerlink" title="一、常用位操作符"></a>一、常用位操作符</h2><h3 id="1-1-位与-amp"><a href="#1-1-位与-amp" class="headerlink" title="1.1 位与&amp;"></a>1.1 位与<code>&amp;</code></h3><h4 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h4><table>
<thead>
<tr>
<th align="center"><code>&amp;</code></th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><code>有0为0，全1为1</code></p>
<h3 id="1-2-位或"><a href="#1-2-位或" class="headerlink" title="1.2 位或|"></a>1.2 位或<code>|</code></h3><h4 id="真值表-1"><a href="#真值表-1" class="headerlink" title="真值表"></a>真值表</h4><p>|<code>|</code>|1|0|<br>|:-:|:-:|:-:|<br>|1|1|1|<br>|0|1|0|</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p><code>有1为1，全0为0</code></p>
<h3 id="1-3-位异或"><a href="#1-3-位异或" class="headerlink" title="1.3 位异或^"></a>1.3 位异或<code>^</code></h3><h4 id="真值表-2"><a href="#真值表-2" class="headerlink" title="真值表"></a>真值表</h4><table>
<thead>
<tr>
<th align="center"><code>^</code></th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p><code>相同为0，相异为1</code></p>
<h3 id="1-4-位取反"><a href="#1-4-位取反" class="headerlink" title="1.4 位取反~"></a>1.4 位取反<code>~</code></h3><p>位取反是将操作数的二进制为逐个按位取反，注意与逻辑取反区分</p>
<h3 id="1-5-左位移-lt-lt-与右位移-gt-gt"><a href="#1-5-左位移-lt-lt-与右位移-gt-gt" class="headerlink" title="1.5 左位移&lt;&lt;与右位移&gt;&gt;"></a>1.5 左位移<code>&lt;&lt;</code>与右位移<code>&gt;&gt;</code></h3><p>C语言的位移运算要取决于其数据类型</p>
<h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><blockquote>
<ul>
<li>左移时右侧补零，为逻辑位移</li>
<li>右移时左侧补零，为逻辑位移</li>
</ul>
</blockquote>
<h4 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h4><blockquote>
<ul>
<li>左移时右侧补零，为算术位移（相当于逻辑位移）</li>
<li>右移时左侧补符号位（<code>正数补0负数补1</code>），为算术位移</li>
</ul>
</blockquote>
<h2 id="二、位运算构建特定二进制数"><a href="#二、位运算构建特定二进制数" class="headerlink" title="二、位运算构建特定二进制数"></a>二、位运算构建特定二进制数</h2><h3 id="2-1-理论基础"><a href="#2-1-理论基础" class="headerlink" title="2.1 理论基础"></a>2.1 理论基础</h3><h4 id="2-1-1-位与、位或、位异或的运算特点"><a href="#2-1-1-位与、位或、位异或的运算特点" class="headerlink" title="2.1.1 位与、位或、位异或的运算特点"></a>2.1.1 位与、位或、位异或的运算特点</h4><blockquote>
<ul>
<li>任何位与<code>1</code>位与<code>无变化</code>，与<code>0</code>位与变成<code>0</code></li>
<li>任何位与<code>1</code>位或变成<code>1</code>，与<code>0</code>位或<code>无变化</code></li>
<li>任何位与<code>1</code>位异或<code>取反</code>，与0位异或<code>无变化</code></li>
</ul>
</blockquote>
<p>所以有：</p>
<blockquote>
<ul>
<li>特定位<code>复位0</code>：与<code>0</code>相<code>&amp;</code></li>
<li>特定位<code>置位1</code>：与<code>1</code>相<code>|</code></li>
<li>特定位<code>取反</code> ：与<code>1</code>相<code>^</code></li>
</ul>
</blockquote>
<h4 id="2-1-2-位移结合位取反构建特定二进制数"><a href="#2-1-2-位移结合位取反构建特定二进制数" class="headerlink" title="2.1.2 位移结合位取反构建特定二进制数"></a>2.1.2 位移结合位取反构建特定二进制数</h4><h5 id="构建特定位为1的二进制数"><a href="#构建特定位为1的二进制数" class="headerlink" title="构建特定位为1的二进制数"></a>构建特定位为1的二进制数</h5><p>(1)<code>bit3~bit7</code>为<code>1</code>，其他位为<code>0</code>的二进制数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> ua = <span class="number">0X1F</span> &lt;&lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><code>0X1F</code>说明这部分有<code>5</code>位，分别为<code>bit0~bit4</code></li>
<li>左移<code>3</code>说明这<code>5</code>位变成了<code>bit3 ~ bit7</code></li>
</ol>
</blockquote>
<p>(2)<code>bit3~bit7</code>为<code>1</code>，<code>bit23~bit25</code>为<code>1</code>，其余位为<code>0</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> ua = <span class="number">0X1F</span> &lt;&lt; <span class="number">3</span> | <span class="number">0X07</span> &lt;&lt; <span class="number">23</span>;</span><br></pre></td></tr></table></figure>

<h5 id="构建特定位为0的二进制数"><a href="#构建特定位为0的二进制数" class="headerlink" title="构建特定位为0的二进制数"></a>构建特定位为0的二进制数</h5><p>先构建特定位为<code>1</code>的二进制数，再进行位取反即可</p>
<p>如<code>bit3~bit7</code>为<code>0</code>，<code>bit23~bit25</code>为<code>0</code>，其余位为<code>1</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> ua = ~ (<span class="number">0X1F</span> &lt;&lt; <span class="number">3</span> | <span class="number">0X07</span> &lt;&lt; <span class="number">23</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-经典操作"><a href="#2-2-经典操作" class="headerlink" title="2.2 经典操作"></a>2.2 经典操作</h3><p><strong>先看明白<code>2.1</code>中的理论基础再看这个！！！</strong></p>
<h4 id="2-2-1-置位特定位"><a href="#2-2-1-置位特定位" class="headerlink" title="2.2.1 置位特定位"></a>2.2.1 置位特定位</h4><p>(1)给定一个无符整型数<code>ua</code>，置位<code>ua</code>的<code>bit3</code>，保证其他位不变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua |= (<span class="number">0X01</span> &lt;&lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>(2)给定一个无符整型数<code>ua</code>，置位<code>ua</code>的<code>bit3~bit7</code>，保证其他位不变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua |= (<span class="number">0X1F</span> &lt;&lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-复位特定位"><a href="#2-2-2-复位特定位" class="headerlink" title="2.2.2 复位特定位"></a>2.2.2 复位特定位</h4><p>(1)给定一个无符整型数<code>ua</code>，复位<code>ua</code>的<code>bit15</code>，保证其他位不变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua &amp;= ~(<span class="number">0X01</span> &lt;&lt; <span class="number">15</span>);</span><br></pre></td></tr></table></figure>

<p>(2)给定一个无符整型数<code>ua</code>，复位<code>ua</code>的<code>bit15~bit23</code>，保证其他位不变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ua |= (<span class="number">0X1FF</span> &lt;&lt; <span class="number">15</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-取出特定位"><a href="#2-2-3-取出特定位" class="headerlink" title="2.2.3 取出特定位"></a>2.2.3 取出特定位</h4><p>给定一个无符整型数<code>ua</code>，置位取出<code>ua</code>的<code>bit3~bit7</code>，存放在<code>ub</code>中</p>
<blockquote>
<ol>
<li>先让特定位保持不变，其他位全部复位</li>
<li>再右移3位得到结果</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> ub = ua;</span><br><span class="line">ub &amp;= (<span class="number">0X1F</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">ub &gt;&gt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-给特定位进行赋值-加减运算"><a href="#2-2-4-给特定位进行赋值-加减运算" class="headerlink" title="2.2.4 给特定位进行赋值/加减运算"></a>2.2.4 给特定位进行赋值/加减运算</h4><p>(1)给寄存器的<code>bit7~bit20</code>赋值<code>845</code>，其余位不受影响</p>
<blockquote>
<ol>
<li>先将特定位全部清零</li>
<li>再进行赋值</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ua &amp;= ~(<span class="number">0X3FFF</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line">ua |= (<span class="number">845</span> &lt;&lt; <span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<p>(2)给寄存器的<code>bit7~bit20</code>赋值<code>845</code>，同时给<code>bit23~bit28</code>赋值<code>548</code>，其余位不受影响</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ua &amp;= ~ ((<span class="number">0X3FFF</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">0X3F</span> &lt;&lt; <span class="number">23</span>));</span><br><span class="line">ua |= ((<span class="number">845</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">548</span> &lt;&lt; <span class="number">23</span>));</span><br></pre></td></tr></table></figure>

<p>(3)将寄存器<code>bit7~bit20</code>中的值加上<code>20</code>,其余位不受影响</p>
<blockquote>
<ol>
<li>先读出特定位的值</li>
<li>给读出的值加上特定数</li>
<li>将特定位清零</li>
<li>对特定位进行赋值</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> ub = ua;</span><br><span class="line">ub &amp;= (<span class="number">0X3FFF</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line">ub &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">ub += <span class="number">20</span>;</span><br><span class="line">ua &amp;= ~ (<span class="number">0X3FFF</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line">ua |= (ub &lt;&lt; <span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<h2 id="三、宏定义完成位操作"><a href="#三、宏定义完成位操作" class="headerlink" title="三、宏定义完成位操作"></a>三、宏定义完成位操作</h2><h3 id="3-1-单独某一位置位"><a href="#3-1-单独某一位置位" class="headerlink" title="3.1 单独某一位置位"></a>3.1 单独某一位置位</h3><p>将<code>ua</code>的第<code>bit_number + 1</code>位置位(<code>第1位对应bit0，下同</code>)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_BIT_NUMBER(UA, BIT_NUMBER)  (\</span></span><br><span class="line">UA | ((typeof (UA))<span class="number">1U</span> &lt;&lt; BIT_NUMBER))</span><br></pre></td></tr></table></figure>

<h3 id="3-2-单独某一位复位"><a href="#3-2-单独某一位复位" class="headerlink" title="3.2 单独某一位复位"></a>3.2 单独某一位复位</h3><p>将<code>ua</code>的第<code>bit_number + 1</code>位复位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_BIT_NUMBER(UA, BIT_NUMBER)(\</span></span><br><span class="line">UA &amp; ~ ((typeof (UA))<span class="number">1U</span> &lt;&lt; BIT_NUMBER))</span><br></pre></td></tr></table></figure>

<h3 id="3-3-连续位置位"><a href="#3-3-连续位置位" class="headerlink" title="3.3 连续位置位"></a>3.3 连续位置位</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>将<code>ua</code>的<code>bit_m + 1</code>位到<code>bit_n + 1</code>位置位</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先需要<code>N = bit_n - bit_m + 1个1</code></p>
<blockquote>
<ol>
<li>得到一个全1的数：<br><code>~ (0U)</code></li>
<li>左移N位得到N个0：<br><code>~ (0U) &lt;&lt; N</code></li>
<li>再进行取反即得到N个1：<br><code>~ (~ (0U) &lt;&lt; N)</code></li>
</ol>
</blockquote>
<p>再左移<code>bit_m</code>位再与原数位或运算即可</p>
<h4 id="参考代码段"><a href="#参考代码段" class="headerlink" title="参考代码段"></a>参考代码段</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_BITS_M_N(UA, BIT_M, BIT_N)  (\</span></span><br><span class="line">UA | (~ (~ ((typeof (UA))<span class="number">0U</span>) &lt;&lt; (\</span><br><span class="line">BIT_N - BIT_M + <span class="number">1</span>)) &lt;&lt; BIT_M))</span><br></pre></td></tr></table></figure>

<h3 id="3-4-连续位复位"><a href="#3-4-连续位复位" class="headerlink" title="3.4 连续位复位"></a>3.4 连续位复位</h3><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><p>将<code>ua</code>的<code>bit_m + 1</code>位到<code>bit_n + 1</code>位复位</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>这个和置位差不多，只是最后一步运算不同而已</p>
<h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_BITS_M_N(UA, BIT_M, BIT_N)(\</span></span><br><span class="line">UA &amp; ~ (~ (~ ((typeof (UA))<span class="number">0U</span>) &lt;&lt; (\</span><br><span class="line">BIT_N - BIT_M + <span class="number">1</span>)) &lt;&lt; BIT_M))</span><br></pre></td></tr></table></figure>

<h3 id="3-5-截取部分连续位"><a href="#3-5-截取部分连续位" class="headerlink" title="3.5 截取部分连续位"></a>3.5 截取部分连续位</h3><h4 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h4><p>将<code>ua</code>的<code>bit_m + 1</code>位到<code>bit_n + 1</code>位取出</p>
<h4 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h4><p>先将其他位复位，再右移即可</p>
<blockquote>
<ol>
<li>和3.3一样先得到N个1：<br><code>~ (~ (0U) &lt;&lt; N)</code></li>
<li>左移<code>bit_m</code>位并与<code>ua</code>相与<br><code>UA &amp; ~ (~ (0U) &lt;&lt; N) &lt;&lt; BIT_M</code></li>
<li>再右移即可</li>
</ol>
</blockquote>
<h4 id="参考代码段-1"><a href="#参考代码段-1" class="headerlink" title="参考代码段"></a>参考代码段</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETBITS_N_M(UA, BIT_M, BIT_N)   (\</span></span><br><span class="line">(UA &amp; ~ (~ ((typeof (UA))<span class="number">0U</span>) &lt;&lt; (\</span><br><span class="line">BIT_N - BIT_M + <span class="number">1</span>)) &lt;&lt; BIT_M) &gt;&gt; BIT_M)</span><br></pre></td></tr></table></figure>

<h3 id="3-5-测试代码"><a href="#3-5-测试代码" class="headerlink" title="3.5 测试代码"></a>3.5 测试代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_BIT_NUMBER(UA, BIT_NUMBER)  (\</span></span><br><span class="line">UA | ((typeof (UA))<span class="number">1U</span> &lt;&lt; BIT_NUMBER))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_BIT_NUMBER(UA, BIT_NUMBER)(\</span></span><br><span class="line">UA &amp; ~ ((typeof (UA))<span class="number">1U</span> &lt;&lt; BIT_NUMBER))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_BITS_M_N(UA, BIT_M, BIT_N)  (\</span></span><br><span class="line">UA | (~ (~ ((typeof (UA))<span class="number">0U</span>) &lt;&lt; (\</span><br><span class="line">BIT_N - BIT_M + <span class="number">1</span>)) &lt;&lt; BIT_M))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_BITS_M_N(UA, BIT_M, BIT_N)(\</span></span><br><span class="line">UA &amp; ~ (~ (~ ((typeof (UA))<span class="number">0U</span>) &lt;&lt; (\</span><br><span class="line">BIT_N - BIT_M + <span class="number">1</span>)) &lt;&lt; BIT_M))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETBITS_N_M(UA, BIT_M, BIT_N)   (\</span></span><br><span class="line">(UA &amp; ~ (~ ((typeof (UA))<span class="number">0U</span>) &lt;&lt; (\</span><br><span class="line">BIT_N - BIT_M + <span class="number">1</span>)) &lt;&lt; BIT_M) &gt;&gt; BIT_M)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> UA = <span class="number">0XF000F000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0X%lX\n"</span>, SET_BIT_NUMBER(UA, <span class="number">3</span>) | SET_BIT_NUMBER(UA, <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0X%lX\n"</span>, RESET_BIT_NUMBER(UA, <span class="number">3</span>) | RESET_BIT_NUMBER(UA, <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0X%lX\n"</span>, SET_BITS_M_N(UA, <span class="number">0</span>, <span class="number">3</span>) | SET_BITS_M_N(UA, <span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0X%lX\n"</span>, RESET_BITS_M_N(UA, <span class="number">12</span>, <span class="number">15</span>) | RESET_BITS_M_N(UA, <span class="number">28</span>, <span class="number">33</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0X%lX\n"</span>, GETBITS_N_M(UA, <span class="number">0</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试结果及分析"><a href="#测试结果及分析" class="headerlink" title="测试结果及分析"></a>测试结果及分析</h4><p>对bit3 和 bit4进行置位如图所示：</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/bit/SETBITNUMBER.png" alt="SETBITNUMBER.png"></p>
<p>对bit0<del>3 和 bit4</del>7 进行置位如图所示：</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/bit/SETBITSMN.png" alt="SETBITSMN.png"></p>
<p>我们可以看到程序的运行结果和上述分析结果是一致的</p>
<p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/C%E9%AB%98%E7%BA%A7/bit/clipboard_20200209025403.png" alt="clipboard_20200209025403.png"></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">C</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">位运算</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/09/%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E7%BD%AE%E4%BD%8D%E4%B8%8E%E5%A4%8D%E4%BD%8D/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
    <article id="post-共用体union与大小端模式" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/07/%E5%85%B1%E7%94%A8%E4%BD%93union%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/">【C语言】共用体union与大小端模式</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/07/%E5%85%B1%E7%94%A8%E4%BD%93union%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/" class="archive-article-date">
  	<time datetime="2020-02-07T14:36:49.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-07</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <h2 id="一、共用体union"><a href="#一、共用体union" class="headerlink" title="一、共用体union"></a>一、共用体union</h2><h3 id="1-1-共用体的定义、变量定义和使用"><a href="#1-1-共用体的定义、变量定义和使用" class="headerlink" title="1.1 共用体的定义、变量定义和使用"></a>1.1 共用体的定义、变量定义和使用</h3><p>共用体<code>union</code>和结构体<code>struct</code>在类型定义、变量定义和使用方法上很相似，如下代码段</p>
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">C</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">共用体</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">大小端模式</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/07/%E5%85%B1%E7%94%A8%E4%BD%93union%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
    <article id="post-【8086汇编】2.访问寄存器和内存" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/06/%E3%80%908086%E6%B1%87%E7%BC%96%E3%80%912.%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/">【8086汇编】2.访问寄存器和内存</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/06/%E3%80%908086%E6%B1%87%E7%BC%96%E3%80%912.%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/" class="archive-article-date">
  	<time datetime="2020-02-06T03:16:49.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-06</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/8086.png" alt="8086"></p>
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">嵌入式</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">8086汇编</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/06/%E3%80%908086%E6%B1%87%E7%BC%96%E3%80%912.%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
    <article id="post-【8086汇编】1.8086汇编基础" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/06/%E3%80%908086%E6%B1%87%E7%BC%96%E3%80%911.8086%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/">【8086汇编】1.8086汇编基础</a>
    </h1>
  


        <span class="archive-article-date"></span>

        <!--显示阅读次数

显示阅读次数完毕-->







        
        <a href="/2020/02/06/%E3%80%908086%E6%B1%87%E7%BC%96%E3%80%911.8086%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/" class="archive-article-date">
  	<time datetime="2020-02-06T03:15:49.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2020-02-06</time>
</a>
        
        </header>
    

    <div class="article-entry" itemprop="articleBody"> 

      
        <p><img src="https://graph-1301143676.cos.ap-chengdu.myqcloud.com/8086.png" alt="8086"></p>
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">嵌入式</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">8086汇编</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/02/06/%E3%80%908086%E6%B1%87%E7%BC%96%E3%80%911.8086%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>

</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>






        <!-- 《添加版权声明 -->
        
          <!-- 《添加版权声明 -->
<!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->


<!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 -->

  <div class="declare" hidden="hidden"></div>

<!-- 添加版权声明》 -->

      
      <!-- 添加版权声明》 -->

  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 Baymaxly
    	</div>
      	<div class="footer-right">
			  @版权所有 转载请注明出处
      	</div>
    </div>
  </div>
</footer>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span id="busuanzi_container_site_uv"> 
	本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>

  
<!--页面点击小红心-->
<script type="text/javascript" src="/love.js"></script>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}


</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script></script><script src="/./main.dabb16.js"></script><script>!function(){var e,t;e="/slider.aea4fb.js",t=document.createElement("script"),document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}()</script>



    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友情链接</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">C</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">宏定义</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">预处理</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Markdown</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">yilia</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Makefile</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">结构体</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">宏</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">typedef</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">嵌入式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">8086汇编</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Cpp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">namespace</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">位运算</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">数组</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">共用体</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">大小端模式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">函数库</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">指针</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">存储类</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">作用域</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">生命周期</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">链接属性</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">数据结构</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">内存管理</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">函数</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">C/C++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">线性表</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">UDT</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="https://blog.whutech.club/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>武汉理工大学电子科技协会官方博客</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">初来乍到， 方向为嵌入式，不会前端， 博客多为学习笔记，如有错误，敬请指正</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

